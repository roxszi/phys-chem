import{_ as fe,p as P,q as ge,C as X,b as _,o as p,w as f,G as g,e as A,j as h,c as V,a as m,ac as he,ad as ye,t as pe,V as Ce}from"./framework.CjnDDKZX.js";import{u as xe,a as we,o as _e,b as F}from"./index.D1Z3afjH.js";import{L as Se,M as ke,D as Ee,A as Me,U as Pe,S as Re,a as Ye}from"./theme.DVzu1JbX.js";const R={loadingInstance:null,dialogInstance:null};function be(y="加载中..."){R.loadingInstance&&R.loadingInstance.hide(),y!==!1&&(R.loadingInstance=Se({delay:0,fullscreen:!0,indicator:!0,inheritColor:!1,loading:!0,preventScrollThrough:!0,showOverlay:!0,size:"large",text:y,zIndex:3500}))}function Ie(y){R.dialogInstance&&R.dialogInstance.destroy(),typeof y=="string"&&(y={body:y});const{theme:d="info",header:Y,body:c,confirmBtn:E,onConfirm:s=()=>{}}=y,k=y.onConfirm?y.cancelBtn||void 0:null;R.dialogInstance=Ee({mode:"modal",placement:"center",theme:d,closeBtn:!1,destroyOnClose:!0,header:Y,body:c,footer:!0,confirmBtn:E,confirmLoading:!1,confirmOnEnter:!0,cancelBtn:k,onConfirm:()=>{s(),R.dialogInstance.destroy()}})}function De(y){typeof y=="string"&&(y={content:y});const{theme:d="info",content:Y,duration:c=1500}=y;ke(d,{closeBtn:!0,content:Y,icon:!0,placement:"center"},c)}const S={loading:be,dialog:Ie,message:De},Xe={style:{width:"100%"}},Ae={key:4,class:"center"},Be={key:0},Te={key:1},Ge={class:"center"},Ne={class:"center"},Ve={__name:"ContactAngle",setup(y){S.loading("正在启动OpenCV.js计算机视觉模块，请稍候...");const d=P(1),Y=P([]),c=P(null),E=xe(c),s=P([0,0,0,255,0,85,170,255,0,255,0,85,170,255]),k=P(!1),M=P(!0),i=P([0,0]),t={cv:null,ctx:null,canvasScaling:0,matGray:null,imageDataGray:null,rectXmax:null,rectYmax:null,rectXmin:null,rectYmin:null,imageDataContour:null,contourPointAoa:[],contourYMin:null},{elementX:L,elementY:H}=we(c);_e(c,$);const{stop:O}=ge([c,E],n=>{const[e,a]=n;e&&a&&(O(),c.value.style.width=E.value.clientWidth+"px",Ce(()=>import("./opencv.DUTv8PWl.js").then(l=>l.o),[]).then(l=>{l.default.then(r=>{t.cv=r,S.loading(!1)})}))});function $(n){try{const e=d.value;e===2?(B(),t.ctx.putImageData(t.imageDataGray,0,0)):e===3&&t.ctx.putImageData(t.imageDataGray,0,0)}catch(e){console.log("onCanvasLongPress()报错：",e),C()}}function q(n){try{const e=d.value;e===2?Z():e===4&&ie()}catch(e){console.log("onCanvasClick()报错：",e),C()}}function B(){try{t.rectXmax=null,t.rectYmax=null,t.rectXmin=null,t.rectYmin=null}catch(n){throw console.log("canvasRectDataRemove()报错：",n),Error(n)}}function T(){try{t.ctx.strokeStyle="red",t.ctx.lineWidth=2*t.canvasScaling}catch(n){throw console.log("ctxSetting()报错：",n),Error(n)}}function b(n){try{const e=d.value;e===3?oe(!1):e===4&&ue()}catch(e){console.log("onSlideChange()报错：",e),C()}}function z(n){try{d.value===3&&M.value===!1&&W()}catch(e){console.log("onContourSlideChangeEnd()报错：",e),C()}}function C(){S.dialog({theme:"danger",header:"报错",body:"请联系软件开发人员"}).catch(n=>{console.log("errorDialog()报错：",n)})}function J(){try{d.value=1}catch(n){throw console.log("taskToStep1()报错：",n),Error(n)}}async function K(n){var e;try{if(n.length===0){J();return}S.loading("正在读取照片...");const a=URL.createObjectURL(n[0].raw),o=new Image;o.style.display="none",o.src=a,await o.decode(),t.canvasScaling=o.naturalWidth/E.value.clientWidth,c.value.style.height=o.naturalHeight/t.canvasScaling+"px";const l=t.cv.imread(o);o.remove(),(e=t.matGray)!=null&&e.delete&&t.matGray.delete(),t.matGray=new t.cv.Mat,t.cv.cvtColor(l,t.matGray,t.cv.COLOR_RGBA2GRAY,0),t.cv.imshow(c.value,t.matGray),l.delete(),t.ctx=c.value.getContext("2d"),T(),t.imageDataGray=t.ctx.getImageData(0,0,c.value.width,c.value.height),Q(),S.loading(!1)}catch(a){S.loading(!1),console.log("onPicChange()方法出错：",a),C()}}function Q(){try{d.value=2}catch(n){throw console.log("taskToStep2()方法出错：",n),Error(n)}}function Z(){try{const n=L.value*t.canvasScaling,e=H.value*t.canvasScaling;if(!t.rectXmax){const u=c.value.width,v=c.value.height,w=Math.min(u/4,v/4),D=w*2/3;t.rectXmax=Math.min(n+w,u),t.rectYmax=Math.min(e+D,v),t.rectXmin=Math.max(n-w,0),t.rectYmin=Math.max(e-D,0),G();return}if(n===t.rectXmax||n===t.rectXmin||e===t.rectYmax||e===t.rectYmin)return;let a=0;if(n>t.rectXmax?t.rectXmax=n:n<t.rectXmin?t.rectXmin=n:a++,e>t.rectYmax?t.rectYmax=e:e<t.rectYmin?t.rectYmin=e:a++,a!==2){G();return}const o=(t.rectYmax-t.rectYmin)/(t.rectXmax-t.rectXmin),l=(e-t.rectYmin)/(n-t.rectXmin),r=(e-t.rectYmin)/(n-t.rectXmax);l>=o?r<=-o?t.rectYmax=e:t.rectXmin=n:r<=-o?t.rectXmax=n:t.rectYmin=e,G();return}catch(n){throw console.log("chooseRect()方法出错：",n),Error(n)}}function G(){try{t.ctx.putImageData(t.imageDataGray,0,0),t.ctx.strokeRect(t.rectXmin,t.rectYmin,t.rectXmax-t.rectXmin,t.rectYmax-t.rectYmin)}catch(n){throw console.log("drawRect()方法出错：",n),Error(n)}}function j(n){try{U(!1)}catch(e){console.log("onSureRect()方法出错：",e),C()}}function ee(n){try{U(!0)}catch(e){console.log("onDetermineRect()方法出错：",e),C()}}function U(n=!1){try{if(!t.rectXmax){n===!0&&(B(),d.value=3);return}const e=t.rectXmax-t.rectXmin,a=t.rectYmax-t.rectYmin,o=new t.cv.Rect(t.rectXmin,t.rectYmin,e,a);B();let l=t.matGray.roi(o);t.cv.imshow(c.value,l),t.matGray.delete(),t.matGray=l,l=null,c.value.style.width=E.value.clientWidth+"px",t.canvasScaling=e/E.value.clientWidth,c.value.style.height=a/t.canvasScaling+"px",T(),t.imageDataGray=t.ctx.getImageData(0,0,c.value.width,c.value.height),n&&te()}catch(e){throw console.log("sureRect()方法出错：",e),Error(e)}}function te(){try{M.value=!0,s.value=[0,0,0,255,0,85,170,255,0,255,0,85,170,255],k.value=!1,d.value=3}catch(n){throw console.log("taskToStep3()方法出错：",n),Error(n)}}function ne(n){try{N(!1)}catch(e){console.log("onContourAlgorithmSwitchChange()方法出错：",e),C()}}function ae(n){try{N(!0)}catch(e){console.log("onDetermineContour()方法出错：",e),C()}}const oe=F(N,500,!0);function N(n=!1){try{if(d.value!==3)return;const e=s.value[0],a=s.value[1];let o=new t.cv.Mat;k.value===!0?t.cv.threshold(t.matGray,o,e,255,t.cv.THRESH_BINARY):t.cv.Canny(t.matGray,o,a,e,3,!1),le(o,n),o.delete()}catch(e){console.log("slideContour()方法出错：",e),C()}}function le(n,e=!1){try{let a=new t.cv.MatVector,o=new t.cv.Mat;t.cv.findContours(n,a,o,t.cv.RETR_LIST,t.cv.CHAIN_APPROX_NONE);let l=new t.cv.Mat;t.matGray.copyTo(l);const r=new t.cv.Scalar(255),u=2*t.canvasScaling;t.cv.drawContours(l,a,-1,r,u,void 0,o,void 0),t.cv.imshow(c.value,l),e===!0&&(re(a),t.imageDataContour=t.ctx.getImageData(0,0,c.value.width,c.value.height),se()),a.delete(),o.delete(),l.delete()}catch(a){throw console.log("makeContour()方法出错：",a),Error(a)}}function re(n){try{S.loading("正在存储轮廓坐标...");const e=[];let a=c.value.height;for(let o=0;o<n.size();o++){const l=n.get(o);for(let r=0;r<l.rows;r++){const u=l.data32S[r*2],v=l.data32S[r*2+1];e.push([u,v]),v<a&&(a=v)}l.delete()}t.contourPointAoa=e,t.contourYMin=a,S.loading(!1)}catch(e){throw S.loading(!1),console.log("contourPointsToAoa()方法出错：",e),Error(e)}}function ce(){try{if(M.value===!1){const n=[s.value[0],s.value[1],0,255,0,85,170,255,0,255,0,85,170,255];s.value=n,M.value=!0}else W(),M.value=!1}catch(n){throw console.log("contourCoarseToggle()方法出错：",n),Error(n)}}function W(){try{const n=s.value[0],e=s.value[1],a=Math.max(0,Math.min(243,n-6)),o=Math.max(0,Math.min(243,e-6)),l=[n,e,a,a+12,a,a+4,a+8,a+12,o,o+12,o,o+4,o+8,o+12];s.value=l}catch(n){throw console.log("refreshContourFineSlider()方法出错：",n),Error(n)}}function se(){try{const n=t.contourYMin||0;T(),d.value=4,I(n,n)}catch(n){throw console.log("taskToStep4()方法出错：",n),Error(n)}}function I(n,e){try{const a=n?Math.floor(n):i.value[0],o=e?Math.floor(e):i.value[1],l=c.value.height,r=Math.floor(l/90),u=Math.max(0,Math.min(l,a-r*3)),v=Math.max(0,Math.min(l,o-r*3)),w=[a,o,u,u+r*6,u,u+r*2,u+r*4,u+r*6,v,v+r*6,v,v+r*2,v+r*4,v+r*6];i.value=w}catch(a){throw console.log("refreshBaselineFineSlider()方法出错：",a),Error(a)}}function ie(){try{const n=L.value*t.canvasScaling,e=H.value*t.canvasScaling,a=c.value.width,l=c.value.height-e;if(n<a*.35){const r=i.value[1],u=a/(a-n)*(l-r)+r;I(u,r)}else if(n>a*.65){const r=i.value[0],u=a/n*(l-r)+r;I(r,u)}else I(l,l)}catch(n){throw console.log("chooseBaseline()方法出错：",n),Error(n)}}const ue=F(me,200,!0);function me(){try{const n=i.value[0],e=i.value[1],a=c.value.width,o=c.value.height,l=o-n,r=o-e;t.ctx.putImageData(t.imageDataContour,0,0),t.ctx.beginPath(),t.ctx.moveTo(0,l),t.ctx.lineTo(a,r),t.ctx.stroke()}catch(n){throw console.log("drawBaseline()方法出错：",n),Error(n)}}function de(n){try{d.value=3}catch(e){throw console.log("onBackToStep3()方法出错：",e),Error(e)}}function ve(n){try{const e=i.value[0],a=i.value[1],l=`已成功获取液滴数据。
    轮廓数据点 ${t.contourPointAoa.length} 个。
    基线左、右截距分别为：${e} px，${a} px。
    后续功能敬请期待！`;S.dialog(l)}catch(e){console.log("onDetermineBaseline()方法出错：",e),C()}}return(n,e)=>{const a=Me,o=Pe,l=X("MySwitch"),r=X("mySpace"),u=X("myButton"),v=Re,w=Ye,D=X("MySpace");return p(),_(D,null,{default:f(()=>[g(a,{theme:"info",title:"功能简介"},{default:f(()=>e[6]||(e[6]=[m(" 1. 点击读取图片文件。读取的图片文件将直接灰度化。"),h("br",null,null,-1),m(" 2. 裁剪图片为合适的尺寸。短按控制边框；长按清空已有选框。"),h("br",null,null,-1),m(" 3. 选择基底线、液滴边缘线。 ")])),_:1,__:[6]}),d.value===1?(p(),_(a,{key:0,theme:"warning",title:"步骤1"},{default:f(()=>e[7]||(e[7]=[m(" 首先点击“点击上传图片”读取图片。"),h("br",null,null,-1),m(" 读取到的图片会自动进行灰度化渲染。 ")])),_:1,__:[7]})):A("",!0),g(o,{disabled:!1,class:"center",theme:"image",multiple:!1,draggable:!1,showImageFileName:!0,abridgeName:[3,8],files:Y.value,"onUpdate:files":e[0]||(e[0]=x=>Y.value=x),autoUpload:!1,sizeLimit:{size:10,unit:"MB"},onChange:K},null,8,["files"]),d.value===2?(p(),_(a,{key:1,theme:"warning",title:"步骤2"},{default:f(()=>e[8]||(e[8]=[m(" 接下来需要将图片裁剪为合适的尺寸。"),h("br",null,null,-1),m(" 点击/触控图片，短按可控制边框；长按可清空已有选框。"),h("br",null,null,-1),m(" 可通过下方“裁剪图片”按钮多次裁剪，直到满意后，点击下方“完成裁剪”按钮进入下一步。 ")])),_:1,__:[8]})):d.value===3?(p(),_(r,{key:2},{default:f(()=>[g(a,{theme:"warning",title:"步骤3"},{default:f(()=>e[9]||(e[9]=[m(" 接下来寻找液滴的最佳轮廓。"),h("br",null,null,-1),m(" 推荐Canny算法，效果更好。对于一些特殊情况的液滴照片，也可以尝试传统的阈值化算法。"),h("br",null,null,-1),m(" 调节滑轨可调整参数并查看轮廓效果；长按可清空效果。 ")])),_:1,__:[9]}),g(l,{onChange:ne,modelValue:k.value,"onUpdate:modelValue":e[1]||(e[1]=x=>k.value=x),leftLabel:"Canny法",rightLabel:"阈值化法"},null,8,["modelValue"]),k.value===!1?(p(),_(a,{key:0,theme:"info"},{default:f(()=>e[10]||(e[10]=[m(" Canny算法是一种多阶段的边缘检测算法，由John F. Canny提出。其原理为计算图像中像素色阶变化的梯度及方向，得到“边缘”图案。然后通过给定的两个阈值参数以筛选出合适的轮廓。"),h("br",null,null,-1),m(" 主参数：亦称“高阈值”，所有色阶变化高于此参数的边缘，都将被认定为“轮廓”。"),h("br",null,null,-1),m(" 辅助参数：亦称“低阈值”，对于色阶变化小于“高阈值”、但与轮廓相连的边缘而言，若其色阶变化大于“低阈值”，则也将被认定为轮廓的一部分。以此确保轮廓的完整性。 ")])),_:1,__:[10]})):(p(),_(a,{key:1,theme:"info"},{default:f(()=>e[11]||(e[11]=[m(" 阈值化是一种传统的二值化处理方法。其原理为将图像中的像素色阶值与所给定的阈值进行比较，大于阈值的像素值将被设定为“白色”，小于阈值的像素值将被设定为“黑色”。然后将黑白之间的边界线认定为轮廓。"),h("br",null,null,-1),m(" 主参数：亦称“阈值”，所有色阶值高于此参数的像素，都将被认定为“白色”。 ")])),_:1,__:[11]}))]),_:1})):d.value===4?(p(),_(a,{key:3,theme:"warning",title:"步骤4"},{default:f(()=>e[12]||(e[12]=[m(" 接下来寻找固体基底与液滴接触的“基线”。"),h("br",null,null,-1),m(" 点击/触控图片以粗调基线位置；调节滑轨以细调。 ")])),_:1,__:[12]})):A("",!0),h("div",Xe,[he(h("canvas",{ref_key:"canvasRef",ref:c,onClick:q},null,512),[[ye,d.value>=2]])]),d.value===2?(p(),V("div",Ae,[g(u,{onClick:j,block:!1},{default:f(()=>e[13]||(e[13]=[m(" 裁剪图片 ")])),_:1,__:[13]}),g(u,{onClick:ee,block:!1,theme:"danger"},{default:f(()=>e[14]||(e[14]=[m(" 完成裁剪 ")])),_:1,__:[14]})])):d.value===3?(p(),_(r,{key:5,size:"small"},{default:f(()=>[k.value===!1?(p(),V("div",Be,"主参数（G色阶变化）：")):(p(),V("div",Te,"主参数（G色阶值）：")),g(v,{onChange:b,onChangeEnd:z,inputNumberProps:!1,label:!0,layout:"horizontal",range:!1,min:s.value[2],max:s.value[3],step:1,marks:[s.value[4],s.value[5],s.value[6],s.value[7]],modelValue:s.value[0],"onUpdate:modelValue":e[2]||(e[2]=x=>s.value[0]=x)},null,8,["min","max","marks","modelValue"]),g(w),k.value===!1?(p(),_(r,{key:2,size:"small"},{default:f(()=>[e[15]||(e[15]=h("div",null,"辅助参数（G色阶变化）：",-1)),g(v,{onChange:b,onChangeEnd:z,inputNumberProps:!1,label:!0,layout:"horizontal",range:!1,min:s.value[8],max:s.value[9],step:1,marks:[s.value[10],s.value[11],s.value[12],s.value[13]],modelValue:s.value[1],"onUpdate:modelValue":e[3]||(e[3]=x=>s.value[1]=x)},null,8,["min","max","marks","modelValue"]),g(w)]),_:1,__:[15]})):A("",!0),h("div",Ge,[g(u,{onClick:ce,block:!1,theme:M.value?"primary":"warning"},{default:f(()=>[m(pe(M.value?"切换细调":"切换粗调"),1)]),_:1},8,["theme"]),g(u,{onClick:ae,disabled:s.value[0]===0,block:!1,theme:"danger"},{default:f(()=>e[16]||(e[16]=[m(" 确认轮廓 ")])),_:1,__:[16]},8,["disabled"])])]),_:1})):d.value===4?(p(),_(r,{key:6,size:"small"},{default:f(()=>[e[19]||(e[19]=h("div",null,"左截距（px）：",-1)),g(v,{onChange:b,onchangeEnd:null,inputNumberProps:!1,label:!0,layout:"horizontal",range:!1,min:i.value[2],max:i.value[3],step:1,marks:[i.value[4],i.value[5],i.value[6],i.value[7]],modelValue:i.value[0],"onUpdate:modelValue":e[4]||(e[4]=x=>i.value[0]=x)},null,8,["min","max","marks","modelValue"]),g(w),e[20]||(e[20]=h("div",null,"右截距（px）：",-1)),g(v,{onChange:b,onchangeEnd:null,inputNumberProps:!1,label:!0,layout:"horizontal",range:!1,min:i.value[8],max:i.value[9],step:1,marks:[i.value[10],i.value[11],i.value[12],i.value[13]],modelValue:i.value[1],"onUpdate:modelValue":e[5]||(e[5]=x=>i.value[1]=x)},null,8,["min","max","marks","modelValue"]),g(w),h("div",Ne,[g(u,{onClick:de,block:!1,theme:"default"},{default:f(()=>e[17]||(e[17]=[m(" 返回上一步 ")])),_:1,__:[17]}),g(u,{onClick:ve,disabled:s.value[0]===0,block:!1,theme:"danger"},{default:f(()=>e[18]||(e[18]=[m(" 确认基线 ")])),_:1,__:[18]},8,["disabled"])])]),_:1,__:[19,20]})):A("",!0)]),_:1})}}},Ue=fe(Ve,[["__scopeId","data-v-d9f1b50d"]]);export{Ue as default};
